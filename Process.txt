**Process Management**

Process is nothing but a program in execution

Example -  Work is a program and the work i was doing can be said as a process.

->Programming
->Debugging
->Testing

so on....

Process needs resources to complete its task
When the computer is given with the tasks and the execution of that tasks is a process
The program is loaded into the memory is known as the proces
and it as four types 
->Stack- Process Stack contains the temporary Data such as method/function, return address, and local variables
->heap - Dynamically allocated memory 
->Text - General Current activity representated by the value of program counter 

Process Life Cycle

1. Start - This is initial state 
2. Ready- The Process is ready to be assigned 
3. Running - Once the process has been assigned to a processor by the scheduler
4. Waiting - Process needs to be in waiting state when there is no resources
5. Terminated or Exit - Once, the process finshes its execution it will be terminated by the operating system 

-----------------------------------------------------------
Process control block

This represents a information about a specific process

->The operating system will create a data structure to store the information about the process 
->The process control block is kept in a memory area that is protected from the normal user access

Process Control Block is a data structure that contains information of the process related to it. The process control block is also known as a task control block, entry of the process table, etc.

It is very important for process management as the data structuring for processes is done in terms of the PCB. It also defines the current state of the operating system.

Structure of the Process Control Block
The process control stores many data items that are needed for efficient process management. Some of these data items are explained with the help of the given diagram −

The following are the data items −

Process State
This specifies the process state i.e. new, ready, running, waiting or terminated.

Process Number
This shows the number of the particular process.

Program Counter
This contains the address of the next instruction that needs to be executed in the process.

Registers
This specifies the registers that are used by the process. They may include accumulators, index registers, stack pointers, general purpose registers etc.

List of Open Files
These are the different files that are associated with the process

CPU Scheduling Information
The process priority, pointers to scheduling queues etc. is the CPU scheduling information that is contained in the PCB. This may also include any other scheduling parameters.

Memory Management Information
The memory management information includes the page tables or the segment tables depending on the memory system used. It also contains the value of the base registers, limit registers etc.

I/O Status Information
This information includes the list of I/O devices used by the process, the list of files etc.

Accounting information
The time limits, account numbers, amount of CPU used, process numbers etc. are all a part of the PCB accounting information.

Location of the Process Control Block
The process control block is kept in a memory area that is protected from the normal user access. This is done because it contains important process information. Some of the operating systems place the PCB at the beginning of the kernel stack for the process as it is a safe location.

***Process Control block (PCB) is a data structure that stores information of a process. PCBs are stored in specially reserved memory for the operating system known as kernel space.***
***Process Control Block (PCB) does not contain the boostrap program***
**The Number of process completed per unit time is known as Throughput.**

Degree of Multiprogramming - The Number of processes in Memory.

----------------------------------------------------------

Process Stage - The Condition of the Process States

__Process__Queues___

Process Queue is used to hold the process related process control blocks, When the process make transition from one state to another state the pcb is un-linked and assigned to the other process with the help of process scheduling 

The Operating system manages various types of queues for each of the process states. The PCB related to the process is also stored in the queue of the same state. If the Process is moved from one state to another state then its PCB is also unlinked from the corresponding queue and added to the other state queue in which the transition is made.

1. Job Queue
In starting, all the processes get stored in the job queue. It is maintained in the secondary memory. The long term scheduler (Job scheduler) picks some of the jobs and put them in the primary memory.

2. Ready Queue
Ready queue is maintained in primary memory. The short term scheduler picks the job from the ready queue and dispatch to the CPU for the execution.

3. Waiting Queue
When the process needs some IO operation in order to complete its execution, OS changes the state of the process from running to waiting. The context (PCB) associated with the process gets stored on the waiting queue which will be used by the Processor when the process finishes the IO.


->Process Scheduling 

Comparison among Scheduler

 Long-Term Scheduler	                           Short-Term Scheduler                                    Medium-Term Scheduler
 
-It is a job scheduler	                        -It is a CPU scheduler	                                -It is a process swapping scheduler.
-Speed is lesser than short term scheduler	    -Speed is fastest among other two	               -Speed is in between both short and long term scheduler.
-It controls the degree of multiprogramming	 -It provides lesser control over degree of multiprogramming	-It reduces the degree of multiprogramming.
-It is almost absent or minimal in time sharing system	-It is also minimal in time sharing system	      -It is a part of Time sharing systems.
-It selects processes from pool                	-It selects those processes which are ready to execute	   -It can re-introduce                            and loads them into memory for execution                                                                    the process into memory and execution can be continued.


Scheduling removes a currently running job from the processor and picks another task to perform. Process Scheduling divides a process into stages: ready, waiting, and running.

There are two ways of scheduling:

1. Non-Preemptive: The resource cannot be withdrawn from a process in non-preemptive until the process has completed execution. Resources are switched when a running process quits and changes to a waiting state.

2. Preemptive: The operating system provides resources to a process for a set period in preemptive scheduling. During the allocation of resources, the process transitions from running to ready or from waiting to ready. This switching happens because the CPU may grant precedence to other processes and substitute the executing process with a higher priority process.

Types of Process Scheduling

1). Long-Term Scheduler

A long-term scheduler determines which system should process programs. It uses CPU Scheduling to select and load programs into memory for execution. It manages the degree of multiprogramming and offers a balanced combination of jobs such as I/O bound and CPU bound.

A steady degree of multiprogramming indicates that the average rate of initialization and the average rate of process departure from the system are equal. Many systems, such as time-sharing operating systems, do not have a long-term scheduler since it is only necessary when a process transitions from new to ready.

Example of a Long Term Scheduler

Consider a long-term scheduler that creates all I/O bound processes. In this case, the CPU will remain idle for most of the time and we will not be utilizing our CPU to its full potential. On the other hand, if a long-term scheduler creates all CPU-bound processes, then the I/O waiting for queue will remain idle for most of the time, the devices will remain unused, and the CPU will remain busy for a long time.

In these scenarios, we will not be utilizing the complete potential of our system. However, if the long term scheduler creates processes that have a perfect balance of both the CPU bound and I/O bound jobs, we will be utilizing the system to its full potential, hence reducing the process time.

2). Medium-Term Scheduler

Medium-term scheduling, which is part of swapping, removes programs from memory. It lowers the amount of multiprogramming and handles the switched-out processes. For enhancing the process mix, swapping is required.

The use of medium term scheduler is to improve multiprogramming by allowing multiple processes to reside in main memory by swapping out processes that are waiting (need I/O) or low priority processes and swapping in other processes that were in ready queue.

When a current process makes an I/O request, it is suspended, which cannot be performed. As a result, the suspended process is transferred to secondary storage to free up memory for other operations. This is known as switching, and the act of swapping is referred to as switched out or rolled out.

For example, in the round-robin process, after a fixed time quantum, the process is again sent to the ready state from the running state. So, these things are done with the help of Medium-Term schedulers.

3). Short-Term Scheduler
A short-term scheduler, often known as a CPU scheduler, boosts system performance based on a predefined set of parameters. This is the process's transition from the ready state to the operating state.

It chooses one of the many processes ready to be executed and assigns the CPU to one of them. It is speedier than long-term schedulers, and it is also known as a dispatcher since it decides which process will be run next.

Short-term scheduling involves selecting one of the processes from the ready queue and scheduling them for execution. This is done by the short-term scheduler. A scheduling algorithm is used to decide which process will be scheduled for execution next by the short-term scheduler.

For example, when a running process is interrupted and may be changed, the short-term scheduler must recalibrate and give the highest-priority job the green light.

(*). Context Switching

A context switching is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features.

When the scheduler switches the CPU from executing one process to execute another, the state from the current running process is stored into the process control block. After this, the state for the process to run next is loaded from its own PCB and used to set the PC, registers, etc. At that point, the second process can start executing.
